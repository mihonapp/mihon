-- Updates cache queries
-- This file provides efficient queries against the pre-computed updates_cache table
-- Replaces the slow updatesView with a cached table updated via triggers

import kotlin.Boolean;

CREATE TABLE IF NOT EXISTS updates_cache (
    _id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    manga_id INTEGER NOT NULL,
    manga_title TEXT NOT NULL,
    chapter_id INTEGER NOT NULL,
    chapter_name TEXT NOT NULL,
    scanlator TEXT,
    chapter_url TEXT NOT NULL,
    read INTEGER AS Boolean NOT NULL,
    bookmark INTEGER AS Boolean NOT NULL,
    last_page_read INTEGER NOT NULL,
    source INTEGER NOT NULL,
    favorite INTEGER AS Boolean NOT NULL,
    thumbnail_url TEXT,
    cover_last_modified INTEGER NOT NULL,
    date_upload INTEGER NOT NULL,
    date_fetch INTEGER NOT NULL,
    FOREIGN KEY (manga_id) REFERENCES mangas(_id) ON DELETE CASCADE,
    FOREIGN KEY (chapter_id) REFERENCES chapters(_id) ON DELETE CASCADE
);

-- Get recent updates
getRecentUpdates:
SELECT
    manga_id AS mangaId,
    manga_title AS mangaTitle,
    chapter_id AS chapterId,
    chapter_name AS chapterName,
    scanlator,
    chapter_url AS chapterUrl,
    read,
    bookmark,
    last_page_read,
    source,
    favorite,
    thumbnail_url AS thumbnailUrl,
    cover_last_modified AS coverLastModified,
    date_upload AS dateUpload,
    date_fetch AS datefetch
FROM updates_cache
WHERE date_upload > :after
ORDER BY date_fetch DESC
LIMIT :limit;

-- Get updates by read status
getUpdatesByReadStatus:
SELECT
    manga_id AS mangaId,
    manga_title AS mangaTitle,
    chapter_id AS chapterId,
    chapter_name AS chapterName,
    scanlator,
    chapter_url AS chapterUrl,
    read,
    bookmark,
    last_page_read,
    source,
    favorite,
    thumbnail_url AS thumbnailUrl,
    cover_last_modified AS coverLastModified,
    date_upload AS dateUpload,
    date_fetch AS datefetch
FROM updates_cache
WHERE read = :read
AND date_upload > :after
ORDER BY date_fetch DESC
LIMIT :limit;

-- Get updates for a specific manga
getUpdatesByMangaId:
SELECT
    manga_id AS mangaId,
    manga_title AS mangaTitle,
    chapter_id AS chapterId,
    chapter_name AS chapterName,
    scanlator,
    chapter_url AS chapterUrl,
    read,
    bookmark,
    last_page_read,
    source,
    favorite,
    thumbnail_url AS thumbnailUrl,
    cover_last_modified AS coverLastModified,
    date_upload AS dateUpload,
    date_fetch AS datefetch
FROM updates_cache
WHERE manga_id = :mangaId
ORDER BY date_fetch DESC;

-- Delete all updates cache entries (use for small deletes)
deleteAll:
DELETE FROM updates_cache;

-- Delete a batch of entries (for incremental large deletes)
-- Returns number of deleted rows
deleteBatch:
DELETE FROM updates_cache 
WHERE _id IN (SELECT _id FROM updates_cache LIMIT :batchSize);

countAll:
SELECT COUNT(*) FROM updates_cache;

-- Drop and recreate table (faster for large deletes, reclaims space immediately)
dropTable:
DROP TABLE IF EXISTS updates_cache;

createTable:
CREATE TABLE IF NOT EXISTS updates_cache (
    _id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    manga_id INTEGER NOT NULL,
    manga_title TEXT NOT NULL,
    chapter_id INTEGER NOT NULL,
    chapter_name TEXT NOT NULL,
    scanlator TEXT,
    chapter_url TEXT NOT NULL,
    read INTEGER AS Boolean NOT NULL,
    bookmark INTEGER AS Boolean NOT NULL,
    last_page_read INTEGER NOT NULL,
    source INTEGER NOT NULL,
    favorite INTEGER AS Boolean NOT NULL,
    thumbnail_url TEXT,
    cover_last_modified INTEGER NOT NULL,
    date_upload INTEGER NOT NULL,
    date_fetch INTEGER NOT NULL,
    FOREIGN KEY (manga_id) REFERENCES mangas(_id) ON DELETE CASCADE,
    FOREIGN KEY (chapter_id) REFERENCES chapters(_id) ON DELETE CASCADE
);

createIndexDateFetch:
CREATE INDEX IF NOT EXISTS idx_updates_cache_date_fetch ON updates_cache(date_fetch DESC);

createIndexMangaId:
CREATE INDEX IF NOT EXISTS idx_updates_cache_manga_id ON updates_cache(manga_id);

-- Delete old updates (cleanup)
deleteOlderThan:
DELETE FROM updates_cache
WHERE date_fetch < :timestamp;

-- Delete all but the latest :keep entries (keeps the newest :keep rows by date_fetch)
deleteKeepLatest:
DELETE FROM updates_cache
WHERE _id NOT IN (SELECT _id FROM updates_cache ORDER BY date_fetch DESC LIMIT :keep);

-- Refresh updates cache from source tables (inserts only new data)
refreshAll:
INSERT OR IGNORE INTO updates_cache (
    manga_id, manga_title, chapter_id, chapter_name, scanlator, chapter_url,
    read, bookmark, last_page_read, source, favorite, thumbnail_url,
    cover_last_modified, date_upload, date_fetch
)
SELECT
    mangas._id,
    mangas.title,
    chapters._id,
    chapters.name,
    chapters.scanlator,
    chapters.url,
    chapters.read,
    chapters.bookmark,
    chapters.last_page_read,
    mangas.source,
    mangas.favorite,
    mangas.thumbnail_url,
    mangas.cover_last_modified,
    chapters.date_upload,
    chapters.date_fetch
FROM mangas
JOIN chapters ON mangas._id = chapters.manga_id
WHERE mangas.favorite = 1
AND chapters.date_fetch > mangas.date_added;
